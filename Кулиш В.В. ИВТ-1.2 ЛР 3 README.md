# Программирование. Язык СИ.
## Математические операции. Переменные и их типы. Операторы. Циклы. Простые условные конструкции. Основы работы со статическими массивами.

## Лабораторная работа № 3. Задачи.
### Комплект 1: Структуры

1.1: Создать некоторую структуру с указателем на некоторую функцию
-
в качестве поля. Вызвать эту функцию через имя переменной этой структуры и поле указателя на функцию.

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|	
|FunctionPointer|typedef void (*)(const char *)|Тип указателя на функцию, принимающую строку и выводящую приветствие/прощание	|
|MyStruct|struct { int id FunctionPointer func	}|Структура, хранящая идентификатор и указатель на функцию (для обратного вызова)|
|sayHello|void (const char *)|Функция, выводящая "Hello, [name]!"|
|sayGoodbye|void (const char *)|Функция, выводящая "Goodbye, [name]!"|	
|myStruct1|MyStruct|Экземпляр структуры с ID=1 и функцией sayHello		|
|myStruct2|MyStruct|Экземпляр структуры с ID=2 и функцией sayGoodbye		|
|id|int|Поле структуры MyStruct, хранящее числовой идентификатор		|
|func|FunctionPointer|Поле структуры MyStruct, хранящее указатель на функцию		|
|name (в функциях)|const char *|Параметр функций sayHello и sayGoodbye, передающий имя для вывода		|
|main |int (*)(void)|Точка входа в программу		|




```c
#include <stdio.h>

// Определим тип функции, которая будет использоваться в структуре.
typedef void (*FunctionPointer)(const char *);

// Определим структуру, содержащую указатель на функцию.
typedef struct {
    int id; // Пример дополнительного поля
    FunctionPointer func; // Указатель на функцию
} MyStruct;

// Пример функции, которую будем использовать.
void sayHello(const char *name) {
    printf("Hello, %s!\n", name);
}

void sayGoodbye(const char *name) {
    printf("Goodbye, %s!\n", name);
}

int main() {
    // Создаем экземпляр структуры и инициализируем его.
    MyStruct myStruct1 = {1, sayHello};
    MyStruct myStruct2 = {2, sayGoodbye};

    // Вызываем функцию через указатель на функцию в структуре.
    myStruct1.func("Alice"); // Выведет: Hello, Alice!
    myStruct2.func("Bob");   // Выведет: Goodbye, Bob!

    return 0;
}

```

_Результат работы программы:_

![image](https://github.com/user-attachments/assets/c066088d-f2a9-457a-988e-2800995e55d8)


1.2: Создать структуру для вектора в 3-х мерном пространстве. 
-
Реализовать и использховать в своей программе следующие операции над векторами:

• скалярное умножение векторов;

• векторное произведение;

• модуль вектора;

• распечатка вектора в консоли.

В структуре вектора указать имя вектора в качестве отдельного поля этой структуры.

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|


```c
#include <stdio.h>
#include <string.h>
#include <math.h>

// Определяем структуру для вектора
typedef struct {
    char name[20]; // Имя вектора
    double x, y, z; // Координаты вектора
} Vector;

// Функция для вычисления скалярного произведения двух векторов
double dotProduct(Vector v1, Vector v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
}

// Функция для вычисления векторного произведения двух векторов
Vector crossProduct(Vector v1, Vector v2) {
    Vector result;
    result.x = v1.y * v2.z - v1.z * v2.y;
    result.y = v1.z * v2.x - v1.x * v2.z;
    result.z = v1.x * v2.y - v1.y * v2.x;
    return result;
}

// Функция для вычисления модуля вектора
double magnitude(Vector v) {
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

// Функция для вывода вектора в консоль
void printVector(Vector v) {
    printf("Vector %s: (%.2f, %.2f, %.2f)\n", v.name, v.x, v.y, v.z);
}

int main() {
    // Создаем два вектора
    Vector v1 = {"v1", 1.0, 2.0, 3.0};
    Vector v2 = {"v2", 4.0, 5.0, 6.0};

    // Выводим векторы
    printVector(v1);
    printVector(v2);

    // Вычисляем скалярное произведение
    double dot = dotProduct(v1, v2);
    printf("Dot product of %s and %s: %.2f\n", v1.name, v2.name, dot);

    // Вычисляем векторное произведение
    Vector cross = crossProduct(v1, v2);
    strcpy(cross.name, "v1 x v2");
    printf("Cross product of %s and %s:\n", v1.name, v2.name);
    printVector(cross);

    // Вычисляем модуль векторов
    double mag1 = magnitude(v1);
    double mag2 = magnitude(v2);
    printf("Magnitude of %s: %.2f\n", v1.name, mag1);
    printf("Magnitude of %s: %.2f\n", v2.name, mag2);

    return 0;
}

```

_Результат работы программы:_

![image](https://github.com/user-attachments/assets/e0eaf8a5-dfe7-4729-a207-0609b4ac767c)



1.3: Вычислить, используя структуру комплексного числа, комплексную экспоненту exp(z) некоторого z ∈ C:
-
![image](https://github.com/user-attachments/assets/2a4795b2-9c17-4bb4-bea7-d1bd26a0afb2)

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|


```c

```

_Результат работы программы:_




1.4: Используя так называемые "битовые" поля в структуре C, создать экономную структуру в оперативной памяти для заполнения даты некоторого события, например даты рождения человека. 
-

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|


```c

```

_Результат работы программы:_




1.5: Реализовать в виде структур двунаправленный связный список и совершить отдельно его обход в прямом и обратном направлениях с распечаткой значений каждого элемента списка.
-

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|


```c

```

_Результат работы программы:_




### Комплект 2: Объединения и перечисления

2.1: Напишите программу, которая использует указатель на некоторое объединение union.
-

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|


```c

```

_Результат работы программы:_




2.2: Напишите программу, которая использует union для побайтовой распечатки типа unsigned long.
-

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|


```c

```

_Результат работы программы:_




2.3: Создайте перечислимый тип данных (enum) для семи дней недели и распечатайте на экране его значения, как целые числа.
-

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|


```c

```

_Результат работы программы:_




2.4: Создайте так называемое размеченное объединение union, 
-
которое заключено в виде поля структуры struct вместе с ещё одним полем, которое является перечислением enum и служит индикатором того, что именно на текущий момент хранится в таком вложенном объединении. Создать и заполнить динамический массив таких структур с объединениями внутри, заполняя вспомогательное поле перечисления enum для сохранения информации о хранимом в каждом размеченном объединении типе данных. Реализовать распечатку данных массива таких структур в консоль.

|Имя переменной|Тип данных|Смысловое обозначение|
|-|-|-|


```c

```

_Результат работы программы:_



